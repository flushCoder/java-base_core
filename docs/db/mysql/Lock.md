# Mysql的锁机制
Innodb引擎和MyiSAM引擎
![](https://github.com/flushCoder/java-base_core/blob/master/picture/db/engine.png)

Innodb和MyiSAM最大的区别就是Innodb支持事务,并且采用了行级锁,提高了并发

**表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。   
**行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。   
**页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般   
表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有 并发查询的应用，如一些在线事务处理（OLTP）系统。
### Innodb的锁
Innodb只有通过索引条件检索数据,使用行级锁,否则使用表级锁  
Innodb实现了一下两种类型的行锁。  
- 共享锁(S):又称读锁  
  多个事务对于同一条数据可以共享一把锁,都能访问到数据,不能修改数据  
  加共享锁(select......lock in share mode)
- 排他锁(X):又称写锁  
  不能与其他锁并存,如果一个事务获取到一个数据的排他锁,其实事务就不能获取该行数据的其他锁(共享锁、排他锁),获取排他锁的事务可以对数据进行读取和修改。  
  添加排他锁(select......for update)
  排他锁是指当某个事务对一行数据加上排他锁之后,其他事务不能在其上加其他锁,Innodb引擎在update、insert、delete都会自动给涉及到的数据添加排他锁,select语句默认不加任何锁,所以直接用select......from......没有任何锁的限制  
  
- 意向共享锁(IS)表锁  
  表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的 IS 锁。如果需要对记录 A 加共享锁，那么此时 InnoDB 会先找到这张表，对该表加意向共享锁之后，再对记录 A 添加共享锁
- 意向排他锁(IX)表锁  
  表示事务准备给数据行加入排他锁，也就是说事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。如果需要对记录 A 加排他锁，那么此时 InnoDB 会先找到这张表，对该表加意向排他锁之后，再对记录 A 添加排他锁
  
  意向锁是 InnoDB 自动加的，不需要用户干预
  
  ![](https://github.com/flushCoder/java-base_core/blob/master/picture/db/lock.jpg)

- 间隙锁
  基于索引的范围筛选条件(排他锁条件含有索引字段的范围)     
  在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。
  
### Mysql的表锁
Mysql的表级锁有两种模式:表共享读锁(Table Read Lock)、表独占写锁(Table Write Lock)  
加锁命令:
```sql
lock table table_name lock read;  --读锁
lock table table_name lock write; --写锁
unlock tables;  --释放锁
```
当一个线程获得对一个表的写锁,只有持有锁的线程可以对表进行操作,其他线程的读、写都会进行等待指导锁被释放  
当一个线程获得对一个表的读锁,改线程只能读取该表数据,修改会报错  
在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预