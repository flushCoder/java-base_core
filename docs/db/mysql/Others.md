# MySQL的脏读、幻读、不可重复读及隔离级别
并发事务带来的问题:脏读、幻读、不可重复读
#### 脏读
读取未提交的数据

#### 幻读
前后多次读取,数据总量不一致  
事务A需要读取两次数据,前一次查询数据后,事务B新插入一条数据,导致事务A进行第二次读取时,读取到的数据数量和第一次不同

#### 不可重复读
前后多次读取,数据内容不一致  
事务A两次查询同一条数据,第一次查询数据后,事务B对数据进行了修改,导致事务A进行第二次查询出的数据和第一次内容不同

#### 不可重复读和幻读的区别
不可重复读是读取了其他事务更改的数据,针对同一条数据而言,主要是update语句
解决:使用行锁锁定该行
  
幻读是读取了其他事务新增的数据,针对insert,delete操作  

#### 隔离级别

- 读不提交(Read Uncommited)  
 这种隔离级别下,事务间完全不隔离,会产生脏数据,可以读取未提交的记录,实际情况下不会使用。
- 读提交(Read Commited)  
这种隔离级别下读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）  
- 可重复读(Repeatable Read)[Mysql默认隔离级别]  
 在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同一个事务同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象
- 串行化(Serializble)
读操作会隐式获取共享锁，可以保证不同事务间的互斥  

![](https://github.com/flushCoder/java-base_core/blob/master/picture/db/isolation.png)